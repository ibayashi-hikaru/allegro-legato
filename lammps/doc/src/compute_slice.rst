.. index:: compute slice

compute slice command
=====================

Syntax
""""""

.. parsed-literal::

   compute ID group-ID slice Nstart Nstop Nskip input1 input2 ...

* ID, group-ID are documented in :doc:`compute <compute>` command
* slice = style name of this compute command
* Nstart = starting index within input vector(s)
* Nstop = stopping index within input vector(s)
* Nskip = extract every Nskip elements from input vector(s)
* input = c_ID, c_ID[N], f_ID, f_ID[N]

  .. parsed-literal::

       c_ID = global vector calculated by a compute with ID
       c_ID[I] = Ith column of global array calculated by a compute with ID
       f_ID = global vector calculated by a fix with ID
       f_ID[I] = Ith column of global array calculated by a fix with ID
       v_name = vector calculated by an vector-style variable with name

Examples
""""""""

.. code-block:: LAMMPS

   compute 1 all slice 1 100 10 c_msdmol[4]
   compute 1 all slice 301 400 1 c_msdmol[4] v_myVec

Description
"""""""""""

Define a calculation that "slices" one or more vector inputs into
smaller vectors, one per listed input.  The inputs can be global
quantities; they cannot be per-atom or local quantities.
:doc:`Computes <compute>` and :doc:`fixes <fix>` and vector-style
:doc:`variables <variable>` can generate such global quantities.  The
group specified with this command is ignored.

The values extracted from the input vector(s) are determined by the
*Nstart*, *Nstop*, and *Nskip* parameters.  The elements of an input
vector of length N are indexed from 1 to N.  Starting at element
*Nstart*, every Mth element is extracted, where M = *Nskip*, until
element *Nstop* is reached.  The extracted quantities are stored as a
vector, which is typically shorter than the input vector.

Each listed input is operated on independently to produce one output
vector.  Each listed input must be a global vector or column of a
global array calculated by another :doc:`compute <compute>` or
:doc:`fix <fix>`.

If an input value begins with "c\_", a compute ID must follow which has
been previously defined in the input script and which generates a
global vector or array.  See the individual :doc:`compute <compute>` doc
page for details.  If no bracketed integer is appended, the vector
calculated by the compute is used.  If a bracketed integer is
appended, the Ith column of the array calculated by the compute is
used.  Users can also write code for their own compute styles and :doc:`add them to LAMMPS <Modify>`.

If a value begins with "f\_", a fix ID must follow which has been
previously defined in the input script and which generates a global
vector or array.  See the individual :doc:`fix <fix>` page for
details.  Note that some fixes only produce their values on certain
timesteps, which must be compatible with when compute slice references
the values, else an error results.  If no bracketed integer is
appended, the vector calculated by the fix is used.  If a bracketed
integer is appended, the Ith column of the array calculated by the fix
is used.  Users can also write code for their own fix style and :doc:`add them to LAMMPS <Modify>`.

If an input value begins with "v\_", a variable name must follow which
has been previously defined in the input script.  Only vector-style
variables can be referenced.  See the :doc:`variable <variable>` command
for details.  Note that variables of style *vector* define a formula
which can reference individual atom properties or thermodynamic
keywords, or they can invoke other computes, fixes, or variables when
they are evaluated, so this is a very general means of specifying
quantities to slice.

If a single input is specified this compute produces a global vector,
even if the length of the vector is 1.  If multiple inputs are
specified, then a global array of values is produced, with the number
of columns equal to the number of inputs specified.

----------

Output info
"""""""""""

This compute calculates a global vector if a single input value is
specified or a global array with N columns where N is the number of
inputs.  The length of the vector or the number of rows in the array
is equal to the number of values extracted from each input vector.
These values can be used by any command that uses global vector or
array values from a compute as input.  See the :doc:`Howto output <Howto_output>` page for an overview of LAMMPS output
options.

The vector or array values calculated by this compute are simply
copies of values generated by computes or fixes or variables that are
input vectors to this compute.  If there is a single input vector of
intensive and/or extensive values, then each value in the vector of
values calculated by this compute will be "intensive" or "extensive",
depending on the corresponding input value.  If there are multiple
input vectors, and all the values in them are intensive, then the
array values calculated by this compute are "intensive".  If there are
multiple input vectors, and any value in them is extensive, then the
array values calculated by this compute are "extensive".  Values
produced by a variable are treated as intensive.

The vector or array values will be in whatever :doc:`units <units>` the
input quantities are in.

Restrictions
""""""""""""
 none

Related commands
""""""""""""""""

:doc:`compute <compute>`, :doc:`fix <fix>`, :doc:`compute reduce <compute_reduce>`

Default
"""""""

none
